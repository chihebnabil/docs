---
title: "RLS Policies"
description: "Migrating Row Level Security policies from Lovable to your Supabase"
icon: "lock"
---

# RLS Policies

Row Level Security (RLS) is where migrations succeed or fail. Here's how we ensure your data stays secure.

## What Are RLS Policies?

RLS policies control who can see and modify data in your database. They're your security layer.

```sql
-- Example: Only let users see their own profiles
CREATE POLICY "Users can only see own profile"
ON public.profiles
FOR SELECT
USING (auth.uid() = user_id);
```

Without proper RLS:
- ❌ User A sees User B's data
- ❌ Anyone can delete any record
- ❌ Data leaks to unauthorized users

## The Migration Challenge

<Warning>
  RLS policies are complex. One wrong policy = security breach.
</Warning>

**Why RLS is tricky to migrate**:

1. **Logic dependencies**: Policies reference tables, functions, and auth state
2. **Order matters**: Tables must exist before policies can be applied
3. **Testing is hard**: You need real auth context to verify
4. **Subtle bugs**: `AND` vs `OR`, `=` vs `!=` can break everything
5. **Performance**: Bad policies slow down every query

## Our Migration Process

<Steps>
  <Step title="Policy Extraction">
    **We extract every policy from your Lovable database:**
    
    ```sql
    SELECT 
      schemaname,
      tablename,
      policyname,
      permissive,
      roles,
      cmd,
      qual as using_expression,
      with_check
    FROM pg_policies
    WHERE schemaname = 'public';
    ```
    
    **What we capture**:
    - Policy name
    - Target table
    - Operation (SELECT, INSERT, UPDATE, DELETE)
    - Using expression (the filter)
    - With check expression (for INSERT/UPDATE)
    - Applied roles
  </Step>
  
  <Step title="Policy Analysis">
    **We analyze each policy for:**
    
    - **Complexity**: Simple (`user_id = auth.uid()`) vs Complex (multiple conditions)
    - **Dependencies**: References to other tables, functions, or views
    - **Performance**: Will it cause full table scans?
    - **Security gaps**: Missing policies, overly permissive rules
    - **Logic errors**: Common mistakes we watch for
    
    **Common issues we catch**:
    ```sql
    -- ❌ Too permissive (allows deleted records)
    USING (user_id = auth.uid())
    
    -- ✅ Better (excludes soft-deleted)
    USING (user_id = auth.uid() AND deleted_at IS NULL)
    ```
  </Step>
  
  <Step title="Dependency Mapping">
    **Policies often reference other objects:**
    
    ```sql
    -- This policy depends on:
    -- 1. The profiles table
    -- 2. The teams table (for the subquery)
    -- 3. The is_team_admin() function
    CREATE POLICY "Team admins can see all team profiles"
    ON public.profiles
    FOR SELECT
    USING (
      auth.uid() = user_id 
      OR 
      is_team_admin(auth.uid(), (
        SELECT team_id FROM teams WHERE user_id = profiles.user_id
      ))
    );
    ```
    
    **We map**: Every table, function, and relationship a policy needs
  </Step>
  
  <Step title="Order of Creation">
    **Policies must be created in the right order:**
    
    1. **Tables first** (obviously)
    2. **Functions** that policies reference
    3. **Base policies** (simple ones without dependencies)
    4. **Complex policies** (with subqueries and function calls)
    5. **Verify** each policy as we go
    
    **Example order**:
    ```sql
    -- 1. Base table policy
    CREATE POLICY "Users see own data" ON orders...;
    
    -- 2. Function that uses orders
    CREATE FUNCTION get_order_total(...) ...;
    
    -- 3. Policy that calls the function
    CREATE POLICY "Admins see totals" ON reports...;
    ```
  </Step>
  
  <Step title="Policy Recreation">
    **We recreate each policy in your new Supabase:**
    
    ```sql
    -- Step 1: Enable RLS on the table
    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
    
    -- Step 2: Force RLS for table owners (recommended)
    ALTER TABLE public.profiles FORCE ROW LEVEL SECURITY;
    
    -- Step 3: Create the policy
    CREATE POLICY "Users can view own profile"
    ON public.profiles
    FOR SELECT
    TO authenticated
    USING (auth.uid() = user_id);
    ```
  </Step>
</Steps>

## Testing RLS Policies

<Card title="We test every policy with real queries" icon="vial">
  Verification is not optional. One untested policy could expose your entire database.
</Card>

### Our Testing Process

<AccordionGroup>
  <Accordion title="Create Test Users">
    ```sql
    -- Create test users in auth.users
    INSERT INTO auth.users (id, email, email_confirmed_at)
    VALUES 
      ('11111111-1111-1111-1111-111111111111', 'user1@test.com', now()),
      ('22222222-2222-2222-2222-222222222222', 'user2@test.com', now()),
      ('33333333-3333-3333-3333-333333333333', 'admin@test.com', now());
    ```
  </Accordion>
  
  <Accordion title="Insert Test Data">
    ```sql
    -- Create records owned by different users
    INSERT INTO public.profiles (user_id, full_name)
    VALUES 
      ('11111111-1111-1111-1111-111111111111', 'User One'),
      ('22222222-2222-2222-2222-222222222222', 'User Two'),
      ('33333333-3333-3333-3333-333333333333', 'Admin User');
    ```
  </Accordion>
  
  <Accordion title="Test SELECT Policies">
    ```sql
    -- Impersonate User 1
    SET LOCAL ROLE authenticated;
    SET LOCAL request.jwt.claim.sub = '11111111-1111-1111-1111-111111111111';
    
    -- User 1 should only see their own profile
    SELECT * FROM public.profiles;
    -- Expected: 1 row (User One)
    
    -- Should NOT see User 2's profile
    SELECT * FROM public.profiles WHERE user_id = '22222222-...';
    -- Expected: 0 rows
    ```
  </Accordion>
  
  <Accordion title="Test INSERT/UPDATE Policies">
    ```sql
    -- User 1 tries to create profile for User 2
    INSERT INTO public.profiles (user_id, full_name)
    VALUES ('22222222-...', 'Impersonating User 2');
    -- Expected: ERROR (violates WITH CHECK)
    
    -- User 1 tries to update their own profile
    UPDATE public.profiles 
    SET full_name = 'Updated Name'
    WHERE user_id = '11111111-...';
    -- Expected: SUCCESS (1 row updated)
    ```
  </Accordion>
  
  <Accordion title="Test DELETE Policies">
    ```sql
    -- User 1 tries to delete User 2's profile
    DELETE FROM public.profiles WHERE user_id = '22222222-...';
    -- Expected: 0 rows (policy prevents this)
    
    -- User 1 deletes their own profile
    DELETE FROM public.profiles WHERE user_id = '11111111-...';
    -- Expected: SUCCESS (if policy allows)
    ```
  </Accordion>
</AccordionGroup>

## Common RLS Patterns

<CardGroup cols={2}>
  <Card title="User-Owned Data" icon="user">
    ```sql
    CREATE POLICY "Users can CRUD own data"
    ON public.items
    FOR ALL
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);
    ```
  </Card>
  
  <Card title="Admin Override" icon="shield">
    ```sql
    CREATE POLICY "Admins can see all"
    ON public.items
    FOR SELECT
    USING (
      auth.uid() = user_id 
      OR 
      EXISTS (
        SELECT 1 FROM public.admins 
        WHERE user_id = auth.uid()
      )
    );
    ```
  </Card>
  
  <Card title="Team Access" icon="users">
    ```sql
    CREATE POLICY "Team members can view"
    ON public.projects
    FOR SELECT
    USING (
      EXISTS (
        SELECT 1 FROM public.team_members
        WHERE user_id = auth.uid()
        AND team_id = projects.team_id
      )
    );
    ```
  </Card>
  
  <Card title="Public Read, Auth Write" icon="globe">
    ```sql
    CREATE POLICY "Public can read"
    ON public.posts
    FOR SELECT
    TO anon, authenticated
    USING (published = true);
    
    CREATE POLICY "Only author can edit"
    ON public.posts
    FOR UPDATE
    TO authenticated
    USING (auth.uid() = author_id);
    ```
  </Card>
</CardGroup>

## RLS Best Practices

<AccordionGroup>
  <Accordion title="Always Enable RLS">
    ```sql
    -- Do this for EVERY table with user data
    ALTER TABLE public.your_table ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.your_table FORCE ROW LEVEL SECURITY;
    ```
    
    **Why**: Even if you have policies, RLS must be enabled to enforce them.
  </Accordion>
  
  <Accordion title="Use auth.uid() Not auth.jwt()->>'sub'">
    ```sql
    -- ✅ Preferred
    USING (user_id = auth.uid())
    
    -- ❌ Avoid (more complex, same result)
    USING (user_id = (auth.jwt()->>'sub')::uuid)
    ```
  </Accordion>
  
  <Accordion title="Index Policy Columns">
    ```sql
    -- If your policy uses user_id, index it!
    CREATE INDEX idx_items_user_id ON public.items(user_id);
    
    -- Otherwise every query scans the entire table
    ```
  </Accordion>
  
  <Accordion title="Test with Real Data">
    Don't just test in SQL editor:
    - Test via your app's API
    - Test via Supabase client
    - Test edge cases (nulls, deleted records)
    - Test performance with large datasets
  </Accordion>
  
  <Accordion title="Document Your Policies">
    Add comments explaining WHY:
    ```sql
    COMMENT ON POLICY "Users can view own profile" 
    ON public.profiles IS 
    'Core privacy policy: users should never see other profiles';
    ```
  </Accordion>
</AccordionGroup>

## Troubleshooting RLS Issues

<AccordionGroup>
  <Accordion title=""Policy is being ignored">
    **Check**: Is RLS enabled?
    ```sql
    SELECT relname, relrowsecurity 
    FROM pg_class 
    WHERE relname = 'your_table';
    -- Should show: relrowsecurity = true
    ```
    
    **Fix**:
    ```sql
    ALTER TABLE public.your_table ENABLE ROW LEVEL SECURITY;
    ```
  </Accordion>
  
  <Accordion title="Users see no data">
    **Check**: Is the policy too restrictive?
    ```sql
    -- Maybe the condition is wrong
    USING (auth.uid() = user_id)  -- user_id might be null
    
    -- Try debugging
    SELECT auth.uid(), user_id, auth.uid() = user_id 
    FROM public.your_table LIMIT 5;
    ```
  </Accordion>
  
  <Accordion title="Users see too much data">
    **Check**: Missing policy or wrong condition
    ```sql
    -- Maybe you forgot the policy
    SELECT * FROM pg_policies WHERE tablename = 'your_table';
    
    -- Or the condition is wrong
    -- ❌ Wrong: OR instead of AND
    USING (auth.uid() = user_id OR deleted_at IS NULL)
    
    -- ✅ Right: Both conditions required
    USING (auth.uid() = user_id AND deleted_at IS NULL)
    ```
  </Accordion>
  
  <Accordion title="Performance is slow">
    **Check**: Are policy columns indexed?
    ```sql
    -- Check if index exists
    SELECT indexname, indexdef 
    FROM pg_indexes 
    WHERE tablename = 'your_table';
    ```
    
    **Fix**: Add index on columns used in policies
  </Accordion>
</AccordionGroup>

## Post-Migration RLS Checklist

<Check>
  - [ ] RLS enabled on all tables with user data
  - [ ] Every table has at least one policy
  - [ ] SELECT policies tested with real users
  - [ ] INSERT policies tested (WITH CHECK verified)
  - [ ] UPDATE policies tested
  - [ ] DELETE policies tested (if applicable)
  - [ ] Admin override policies work
  - [ ] Performance acceptable (no full table scans)
  - [ ] Edge cases handled (nulls, deleted records)
  - [ ] Policies documented
</Check>

<Info>
  **Need help with RLS?** This is included in your 3-credit migration. [Contact us](mailto:support@nextlovable.com) if you have questions.
</Info>
